"""Compute NVDA update recommendations from cached download snapshots.

This helper consumes the JSON artefact generated by
``tools/audit_nvaccess_downloads.py`` and cross-references it with the
validated build manifest plus the add-on ``manifest.ini``.  The goal is to
summarise, in descending modification order, which NVDA downloads should
trigger an update, which ones are safe to ignore, and when a downgrade might
be safer for the Eloquence add-on.

Typical usage::

    python tools/check_nvda_updates.py \
        --snapshot docs/download_nvaccess_snapshot.json \
        --validated docs/validated_nvda_builds.json \
        --manifest manifest.ini \
        --markdown docs/nvda_update_recommendations.md \
        --json docs/nvda_update_recommendations.json

The script prints a concise summary to stdout, writes optional Markdown and
JSON payloads, and maps each severity classification to an actionable
recommendation (for example ``update`` when a build is newer than our last
validated snapshot, or ``downdate`` when a file predates the minimum NVDA
version declared in the manifest).
"""

from __future__ import annotations

import argparse
import json
from dataclasses import asdict
from datetime import UTC, datetime
from typing import Dict, Iterable, List, Optional, Sequence, Tuple

from audit_nvaccess_downloads import (  # type: ignore[import-not-found]
    ListingEntry,
    ManifestInfo,
    Severity,
    classify_entry,
    load_manifest_info,
    load_validated_snapshots,
    parse_release_version,
)


def _load_snapshot_entries(path: str) -> List[ListingEntry]:
    with open(path, "r", encoding="utf-8") as handle:
        payload = json.load(handle)

    entries: List[ListingEntry] = []
    for raw in payload.get("entries", []):
        modified_raw = raw.get("modified")
        modified = None
        if modified_raw:
            try:
                modified = datetime.fromisoformat(str(modified_raw))
            except ValueError:
                modified = None

        entry = ListingEntry(
            path=str(raw.get("path", "")),
            url=str(raw.get("url", "")),
            name=str(raw.get("name", "")),
            entry_type=str(raw.get("entryType", "file")),
            size_bytes=raw.get("sizeBytes"),
            size_display=str(raw.get("sizeDisplay", "")),
            modified=modified,
            target=raw.get("target"),
            depth=int(raw.get("depth", 0)),
        )
        entries.append(entry)

    return entries


def _channel_for_entry(entry: ListingEntry) -> str:
    if entry.path.startswith("snapshots/"):
        parts = entry.path.split("/", 2)
        if len(parts) > 1 and parts[1]:
            return f"snapshot:{parts[1]}"
        return "snapshot"
    if entry.path.startswith("releases/"):
        return "release"
    return "other"


def _recommend_action(severity: Optional[Severity]) -> str:
    if severity is None:
        return "ignore"

    reason = severity.reason.lower()
    if severity.level == "high":
        if "newer" in reason or "ahead" in reason:
            return "update"
        if "no validated" in reason:
            return "investigate"
        return "investigate"
    if severity.level == "medium":
        if "predates" in reason:
            return "downdate"
        if "matches" in reason:
            return "monitor"
        return "monitor"
    if severity.level == "low":
        if "older" in reason or "predates" in reason:
            return "downdate"
        return "monitor"
    return "keep"


def _evaluate_entries(
    entries: Iterable[ListingEntry],
    manifest: ManifestInfo,
    validated: Dict[str, str],
    current_nvda: Optional[str],
) -> List[Tuple[ListingEntry, Optional[str], Optional[Severity], str]]:
    rows: List[Tuple[ListingEntry, Optional[str], Optional[Severity], str]] = []
    for entry in entries:
        severity = classify_entry(entry, manifest, validated, current_nvda)
        version = parse_release_version(entry)
        action = _recommend_action(severity)
        rows.append((entry, version, severity, action))

    rows.sort(key=lambda item: (item[0].modified or datetime.min), reverse=True)
    return rows


def _serialize_entry(
    entry: ListingEntry,
    version: Optional[str],
    severity: Optional[Severity],
    action: str,
) -> Dict[str, object]:
    payload = asdict(entry)
    if entry.modified:
        payload["modified"] = entry.modified.isoformat()
    payload["channel"] = _channel_for_entry(entry)
    payload["version"] = version
    payload["recommendedAction"] = action
    payload["severity"] = severity.to_json() if severity else None
    return payload


def render_markdown(
    rows: Sequence[Tuple[ListingEntry, Optional[str], Optional[Severity], str]]
) -> str:
    lines = [
        "# NVDA update recommendations",
        "",
        "| Modified | Channel | Version | Severity | Action | Notes | Path | Size |",
        "| --- | --- | --- | --- | --- | --- | --- | --- |",
    ]
    for entry, version, severity, action in rows:
        severity_level = severity.level if severity else ""
        notes = severity.reason if severity else ""
        lines.append(
            "| {modified} | {channel} | {version} | {severity} | {action} | {notes} | `{path}` | {size} |".format(
                modified=entry.modified.isoformat(sep=" ") if entry.modified else "",
                channel=_channel_for_entry(entry),
                version=version or "",
                severity=severity_level,
                action=action,
                notes=notes.replace("|", "\\|") if notes else "",
                path=entry.path or "/",
                size=entry.size_display or ("-" if entry.entry_type == "dir" else ""),
            )
        )
    return "\n".join(lines) + "\n"


def summarize(
    rows: Sequence[Tuple[ListingEntry, Optional[str], Optional[Severity], str]]
) -> str:
    lines = ["NVDA update recommendations (newest first)"]
    for entry, version, severity, action in rows[:10]:
        timestamp = entry.modified.isoformat(sep=" ") if entry.modified else "unknown"
        severity_label = severity.level if severity else "-"
        reason = severity.reason if severity else "no release version detected"
        lines.append(
            f"- {timestamp} | {_channel_for_entry(entry)} | {version or entry.name} | "
            f"severity={severity_label} -> action={action}: {reason}"
        )
    if len(rows) > 10:
        lines.append(f"- ... {len(rows) - 10} additional entries not shown")
    return "\n".join(lines)


def main(argv: Optional[Sequence[str]] = None) -> int:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--snapshot",
        default="docs/download_nvaccess_snapshot.json",
        help="Path to cached snapshot JSON produced by audit_nvaccess_downloads",
    )
    parser.add_argument(
        "--validated",
        default="docs/validated_nvda_builds.json",
        help="JSON file describing last validated builds per channel",
    )
    parser.add_argument(
        "--manifest",
        default="manifest.ini",
        help="Path to the add-on manifest used for minimum/last-tested metadata",
    )
    parser.add_argument(
        "--current-nvda",
        help="Optional NVDA version string representing the running environment",
    )
    parser.add_argument(
        "--markdown",
        help="Write a Markdown table to this path",
    )
    parser.add_argument(
        "--json",
        help="Write a machine-readable summary JSON to this path",
    )

    args = parser.parse_args(argv)

    entries = _load_snapshot_entries(args.snapshot)
    validated = load_validated_snapshots(args.validated)
    manifest = load_manifest_info(args.manifest)
    rows = _evaluate_entries(entries, manifest, validated, args.current_nvda)

    print(summarize(rows))

    if args.markdown:
        markdown_payload = render_markdown(rows)
        with open(args.markdown, "w", encoding="utf-8") as handle:
            handle.write(markdown_payload)

    if args.json:
        generated = datetime.now(UTC).isoformat().replace("+00:00", "Z")
        json_payload = {
            "generated": generated,
            "entries": [
                _serialize_entry(entry, version, severity, action)
                for entry, version, severity, action in rows
            ],
        }
        with open(args.json, "w", encoding="utf-8") as handle:
            json.dump(json_payload, handle, indent=2, ensure_ascii=False)

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
